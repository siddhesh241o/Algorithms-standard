// SEG TREE WITH LAZY FOR SUM OF RANGE AND ASSIGNING VALUE TO RANGE
void build(ll ind,ll l,ll r,vector<ll> &p,vector<ll> &seg,vector<ll> &lazy){
    if(l == r){
        seg[ind] = p[l];
        return;
    }
    ll m = (l+r)/2;
    build(2*ind+1,l,m,p,seg,lazy);
    build(2*ind+2,m+1,r,p,seg,lazy);
    seg[ind] = seg[2*ind+1]+seg[2*ind+2];
    return;
}
void update(ll ind,ll l,ll r,ll low,ll high,ll val,vector<ll> &p,vector<ll> &seg,vector<ll> &lazy){
    if(lazy[ind]!=0){
        seg[ind] = (r-l+1)*lazy[ind];
        if(l!=r){
            lazy[2*ind+1] = lazy[ind];
            lazy[2*ind+2] = lazy[ind];
        }
        lazy[ind] = 0;
    }
    if(l>= low && r<= high){
        seg[ind] = (r-l+1)*val;
        if(l!=r){
            lazy[2*ind+1] = val;
            lazy[2*ind+2] = val;
        }
        return;
    }
    if(r<low||l>high||l>r){
        return ;
    }
    ll m = (l+r)/2;
    update(2*ind+1,l,m,low,high,val,p,seg,lazy);
    update(2*ind+2,m+1,r,low,high,val,p,seg,lazy);
    seg[ind] = seg[2*ind+1]+seg[2*ind+2];
    return;
}
ll query(ll ind,ll l,ll r,ll low,ll high,vector<ll> &p,vector<ll> &seg,vector<ll> &lazy){
    if(lazy[ind]!=0){
        seg[ind] = (r-l+1)*lazy[ind];
        if(l!=r){
            lazy[2*ind+1] = lazy[ind];
            lazy[2*ind+2] = lazy[ind];
        }
        lazy[ind] = 0;
    }
    if(l>= low && r<= high){
        return seg[ind];
    }
    if(r<low||l>high||l>r){
        return 0;
    }
    ll m = (l+r)/2;
    return query(2*ind+1,l,m,low,high,p,seg,lazy)+query(2*ind+2,m+1,r,low,high,p,seg,lazy);
}
//lazy segtree class
class lazySegtree{
    public : 
    class node{
        public : 
        ll sum;
        ll lazy;
        void init(ll S){
            sum = S;
            lazy = 0;
        }
    };
    vector<node> seg;
    int n;
    node unite(node a, node b){
        node temp;
        temp.sum = a.sum + b.sum;
        return temp;
    }
    
    void build(ll ind, ll l, ll r, vector<ll> &b){
        if(l == r){
            seg[ind].init(b[l]);
            return;
        }
        ll m = (l + r)/2;
        build(2*ind+1, l, m, b);
        build(2*ind+2, m+1, r, b);
        seg[ind].init(unite(seg[2*ind+1], seg[2*ind+2]).sum);
    }
    
    void update(ll ind, ll l, ll r, ll L, ll R, ll val){
        if(r < L || l > R || l > r) return;   
        if(l >= L && r <= R){
            seg[ind].lazy += val;
            return;
        }   
        applyAggr(ind, l, r);
        ll m = (l + r)/2;
        update(2*ind+1, l, m, L, R, val);
        update(2*ind+2, m+1, r, L, R, val);
        
        applyAggr(2*ind+1, l, m);
        applyAggr(2*ind+2, m+1, r);
        
        seg[ind].sum = unite(seg[2*ind+1], seg[2*ind+2]).sum;
    }
    
    node query(ll ind, ll l, ll r, ll ql, ll qr){
        if(ql > r || qr < l){
            node temp;
            temp.sum = 0;
            return temp;
        }
        applyAggr(ind, l, r);
        if(l >= ql && r <= qr){
            return seg[ind];
        }
        ll m = (l + r)/2;
        return unite(query(2*ind+1, l, m, ql, qr), query(2*ind+2, m+1, r, ql, qr));
    }
    
    void applyAggr(ll ind, ll l, ll r){
        seg[ind].sum += (r - l + 1) * seg[ind].lazy;
        if(l != r){
            compose(ind, 2*ind+1);
            compose(ind, 2*ind+2);
        }
        seg[ind].lazy = 0;
    }
    
    void compose(ll par, ll ind){
        seg[ind].lazy += seg[par].lazy;
    }
    
    lazySegtree(ll N, vector<ll> &b){
        n = N;
        seg.resize(4*n);
        build(0, 0, n-1, b);
    }
    void update(ll L, ll R, ll val){
        update(0, 0, n-1, L, R, val);
    }
    ll query(ll L, ll R){
        return query(0, 0, n-1, L, R).sum;
    }
};
// seg tree with point updates
class segtree{
    public : 
    class node{
        public : 
        void init(){

        }
    };
    vector<node> seg;
    int n;
    node unite(node a, node b){
        
    }
    void build(ll ind,ll l,ll r,vector<ll> &b){
        if(l == r){
            seg[ind].init();
            return;
        }
        ll m = (l + r)/2;
        build(2*ind+1,l,m,b);
        build(2*ind+2,m+1,r,b);
        seg[ind] = unite(seg[2*ind+1], seg[2*ind+2]);
    }
    void update(ll ind,ll l,ll r,ll x,ll val){
        if(x < l || x > r || l > r) return;
        if(l == r){
            seg[ind].init();
            return;
        }
        ll m = (l+r)/2;
        update(2*ind+1,l,m,x,val);
        update(2*ind+2,m+1,r,x,val);
        seg[ind] = unite(seg[2*ind+1], seg[2*ind+2]);
    }
    node query(ll ind,ll l,ll r,ll ql,ll qr){
        if (ql > r || qr < l) {
            
        }
        if(l >= ql && r <= qr){
            return seg[ind];
        }
        ll m = (l + r)/2;
        return unite(query(2*ind+1,l,m,ql,qr),query(2*ind+2,m+1,r,ql,qr));
    }
    segtree(ll N,vector<ll> &b){
        n = N;
        seg.resize(4*n);
        build(0,0,n-1,b);
    }
};
class FenwickTree{
    public:
    ll n; 
    vector<ll> tree;
    FenwickTree(ll N){
        n = N;
        tree.resize(n+1);
    }
    void update(ll idx, ll del){
        idx++;
        while(idx <= n){
            tree[idx] += del;
            idx += idx&-idx;
        }
    }
    ll query(ll idx){
        idx++;
        ll ans = 0;
        while(idx > 0){
            ans += tree[idx];
            idx -= idx&-idx;
        }
        return ans;
    }
    ll rangeQuery(ll a, ll b){
        if(a == 0){
            return query(b);
        }
        return query(b)-query(a-1);
    }
};
